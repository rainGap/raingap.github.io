---
layout: default
title: 贴图格式研究
---

{{ page.title }}
================

## 参考文章
先记录一下最近看的关于DXT压缩格式的文章。

* 一篇国外的高引论文    
    [Texture Compression using Low-Frequency Signal Modulation](/attachments/1.pdf)  
    对现有的图像压缩算法优缺点作了详述，最终提出了一种新的压缩策略。英文，看得有点吃力。
    记录几个专业术语：
    1. 矢量量化(vector quantization)  
    将若干个标量数据组构成一个矢量，然后在矢量空间给以整体量化，从而压缩了数据而不损失多少信息。我的理解是——给两个点求直线方程、霍夫变换，其实都属于矢量量化吧。  
    2. [离散余弦变换( discrete cosine transform DCT)](https://blog.csdn.net/jubincn/article/details/6882179)  
    首先人眼对低频敏感对高频不敏感，由于离散余弦变换具有很强的"能量集中"特性：大多数的自然信号（包括声音和图像）的能量都集中在离散余弦变换后的低频部分，所以可以省去离散余弦变换后矩阵里的高频部分来对图像进行压缩，这是JPEG的主要原理。
    3. 评估一种压缩算法是否有效的四个因素  
        * 解码速度
        * 随机访问能力
        * 压缩比和视觉质量平衡
        （这里提到3D场景里，整个场景的渲染效果比单张贴图精细度更重要，所以他们采用的有损压缩方式可以被容忍）
        * 编码速度

* 云风的blog  DXT 图片压缩  
    [DXT 图片压缩](https://blog.codingnow.com/2007/05/dxt.html)  
    从实现DXT1解码出发，详细介绍了DXT压缩格式，看完对各种情况下的压缩策略有了一定的认识。

## 个人总结

DXT 格式 也叫作 S3TC，对应的文件格式是.dds。  
DXT 格式根据对alpha通道的支持程度，又可以分为DXT1 DXT3 DXT5。  
* DXT1  
	用了1位表示alpha通道，仅能表示某个像素是完全透明的还是完全不透明的。压缩的策略如下：  
	DXT1将图像分为多个4\*4的像素图块，每4\*4个图块作为一个压缩单位，压缩后的数据信息如下图所示：

	![](/images/2019-04-16-12-52-06.png)

	以两个16bits(RGB565，为什么这里要用6位表示G呢，听说是因为人眼对G比较敏感)作为调色板的两个颜色，再将这两个颜色作为基准颜色，插值得到另外两个颜色color_2和color_3，然后以2bits每像素作为索引。

	对于完全不透明的图片  
	``` python
	color_2 = 1/3*color_0 + 2/3*color_1
	color_3 = 2/3*color_0 + 1/3*color_1
	``` 
	对于有透明像素的图片  
	这时候color_2是color_0和color_1的中间值，color_3则表示完全透明。

	所以对于一个4\*4的图像块，我们可以用(16+16+2\*4\*4) = 64bits来表示，压缩比是6:1 (24\*4*\4:64)

* DXT3  
	适用于携带复杂alpha信息的图片压缩。  
	每像素多了4bits用于保存alpha信息，即在原来每像素2bits索引情况下再新增4bits用于保存alpha信息，可以理解为alpha通道(0,255)等分成16份。对比DXT1，每4\*4图块多占用4\*4\*4=64bits
	所以对于一个4\*4的图像块，我们可以用(16+16+2\*4\*4)+64 = 128bits来表示，压缩比是4:1 (32\*4*\4:128)

* DXT5  
	DXT3中将真彩色8位alpha按16个等分容器来装，所以透明度的显示不会很细腻。  
	所以DXT5做了一个巧妙的改进，同样是多64位，用两个16bits作为透明度的调色板，然后用每像素3bits作为透明度的索引，刚好64bit。  
	这3bits可以表示8个插值得到的透明度，由于缩小了插值范围，所以图片的透明度显示相比DXT3会更加细腻。  
	所以一般透明图片建议优先选择DXT5。

![](/images/2019-04-16-22-04-26.png)



